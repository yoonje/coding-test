# Basis of Python Coding Test
Python을 이용한 코딩 테스트 문제 해결을 위한 노하우와 유형별 접근법을 설명합니다.


### 문제 풀이 방법
1. 문제가 어떤 유형에서 출제된 것인지 파악합니다.
2. 암기되어 있던 알고리즘을 사용할 수 있는 문제라면 사용합니다.
3. 입력과 출력을 먼저 읽은 이후 문제를 읽어 입출력을 이해합니다.
4. 문제에서 요구하는 수치와 조건을 정리합니다.
5. 문제에서 해결해야하는 부분을 구체화하고 각각 분리합니다.
6. 주어진 Test Case 이외의 문제에서 해결해야 하는 부분을 적용한 다른 유형의 케이스를 만듭니다.


### 팁
1. 공간을 주고 시간을 사는 전략은 유용하므로 되도록 자료구조를 분리하여 사용하여 코드를 간단하게 만듭니다.
2. 여러가지 케이스가 존재하는 경우 상태 변수를 이용하여 조건식에 넣고 이용합니다.
3. 데이터 처리를 할 때 하의 데이터에 많이 넣ㅈ고 방문을 여러 번하지 말고 변수를 여러 개 선언하여 문제를 간단히 만듭니다. 
4. 구현해야하는 부분이 크거나 반복적이면 함수로 모듈화합니다.
5. 문제에서 요구하는 수치와 조건을 정리할 때 입력의 범위를 보고 시간복잡도를 간단히 계산하여 전수 조사를 할 수 있는 케이스인지 체크합니다.
6. 주어진 Test Case 이외의 Test Case를 추가할 때는 입력에서 극단적으로 줄 수 있는 경우의 수를 반드시 추가합니다.


### Python 자료형
- Python의 integer, boolean, string, float는 immutable한 single 데이터 타입입니다.
- Python의 list, dictionary, set은 mutable한 container 데이터 타입입니다.
- Python의 tuple은 immutable한 container 데이터 타입입니다.
- Python의 int는 객체이기 때문에 overflow가 나지 않습니다.
- Python의 실수는 기본적으로 완전한 비교나 연산이 불가능 할 수 있으므로 정수를 최대한 사용하고 유리수가 필요한 경우 분모와 분자를 튜플로 저장하여 활용합니다.
- Python의 / 연산은 정수끼리의 연산에서도 실수를 반환하므로 // 연산을 주로 사용하는 것이 좋습니다.
- Python의 문자열 연산은 +나 * 를 활용하는 것보다 .join 함수를 사용하는 것이 훨씬 성능을 향상시킵니다.
- Python의 문자열은 Container 타입이 아니고 immutable 데이터 입니다.
- Python의 문자열 슬라이싱은 객체를 새로 생성하는 것이기 때문에 남용하면 안됩니다.
- Python의 문자열의 chr()와 ord() 함수를 통해서 문자열과 아스키 값간의 변환을 쉽게할 수 있습니다.
- Python의 리스트는 append() 함수보다 list comprehension이 더 빠릅니다.
- Python의 sort() 함수는 객체의 메서드이고 sorted()는 내장 함수입니다.
- Python의 리스트의 슬라이싱을 통해 insert() 함수 및 remove() 함수를 효율적으로 쓸 수 있습니다.
- Python의 집합은 중복 체크에서 유용하나 집합 연산의 복잡도가 크므로 주의해서 사용해야합니다.


### String
- 문자열은 파이썬의 내장 자료형으로 문자나 문자열을 이용할 때 사용한다.
- 생성 관련 함수
  - str(): 비어있는 문자열을 생성한다.
  - "": 비어있는 문자열을 생성한다.
- 삽입 관련 함수
  - str.replace(a,b): a라는 문자열을 b라는 문자열로 바꾼다.
  - str.join(str2): str2의 각 사이사이에 str을 삽입하고 리턴한다.
   - str + str2: str과 str2를 더하고 반환한다.
- 참조 관련 함수
  - str[idx]: 해당 인덱스에 있는 문자열의 원소를 리턴한다.
- 탐색 관련 함수
  - str.index(a): a라는 문자가 있으면 그 값의 위치 인덱스를 리턴한다.
  - str.find(a): a라는 문자열을 찾고 인덱스를 리턴한다.
- 기타 함수
  - str.count(a): a라는 문자가 몇개 있는지 개수를 리턴한다.
  - str(객체): 객체를 문자열로 형변환한다.
  - str[start:end]: start ~ end에 있는 문자열의 원소를 리턴한다.
  - str.upper(): str을 대문자로 변환한다.
  - str.lower(): str을 소문자로 변환한다.
  - str.strip(a): 문자열의 양 끝에 a라는 값을 삭제한다. 
  - str.split(구분자): 구분자를 기준으로 문자열을 나누고 리스트로 쪼갠 이후 리턴한다.
  
### List(Vector)
- 리스트는 파이썬의 내장 자료형으로 이름과 달리 내부적으로는 Linked List 방식이 아닌 벡터 형태를 띄고 있는 동적 배열이다.
- 파이썬에도 linked list를 라이브러리로 사용할 수 있으나 일반적으로 linked list보다 list(vector)가 일반적으로 성능이 더 좋기 때문에 linked list는 본 문서에서는 따로 설명하지 않을 것이다.
- 생성 관련 함수
  - list(): 비어 있는 리스트를 생성한다.
  - []: 비어 있는 리스트를 생성한다.
- 삽입 관련 함수
  - list.append(a): a를 list의 맨 뒤에 삽입한다.
  - list.insert(a,b): a번째 위치에 b를 삽입한다.
  - list + list2: list와 list2를 더하고 반환한다.
- 삭제 관련 함수
  - list.remove(a): 앞에서부터 탐색해가며 a라는 값이 나오면 삭제한다.
  - list.pop(): list의 맨 마지막 값을 삭제하고 리턴한다.
- 참조 관련 함수
  - list[idx]: 해당 인덱스에 있는 리스트의 원소를 리턴한다.
- 탐색 관련 함수
  - list.index(a): a라는 값이 있으면 그 값의 위치 인덱스를 리턴한다.
- 기타 함수
  - list(객체): iterable 객체를 리스트로 형변환한다.
  - list[start:end]: start ~ end에 있는 리스트의 원소를 리턴한다.
  - list.reverse(): 리스트를 역순으로 뒤집는다.
  - list.count(a): 리스트 안에 a가 몇개 들어 있는지 카운트한다.
  - list.extend(list2): list에 list2를 이어 확장한다.
  - list + list2: list에 list2를 이어 확장한다.


### Stack, Queue
- `collections.deque`를 통해서 LIFO 형태로 사용하면 쉽게 빠른 stack을 구현할 수 있고 FIFO 형태로 사용하면 Queue를 구현할 수 있다. 이 문서에서는 가장 일반적이고 성능이 좋은 collection.deque를 기반으로 설명할 것이다.
- 스택은 내장 자료형인 list를 LIFO 형태로 사용해도 구현할 수 있으나 linked list 형태로 구현된 collections.deque가 성능에서 더 이점이 있다.
- 큐는 내장 자료형인 list를 FIFO 형태로 사용해도 구현할 수 있으나 linked list 형태로 구현되지 않아서 collections.deque를 사용할 때보다 Head 삭제 시의 O(n)의 복잡도가 추가되어 매우 성능이 떨어진다.
- `병렬 컴퓨팅` 상황에서 스택과 큐 사용에서는 스택은 `queue.LifoQueue`를 큐는 `queue.Queue`를 사용하여 모듈이 지원하는 lock 매커니즘의 내부적인 구현을 활용한다.
- 생성 관련 함수
  - collections.deque(): 비어있는 deque를 생성한다.
- 삽입 관련 함수
  - deque.append(a): a를 deque의 맨 오른쪽에 삽입한다.
  - deque.appendleft(a): a를 deque의 맨 왼쪽에 삽입한다.
  - deque.insert(a,b): a번째 위치에 b를 삽입한다.
- 삭제 관련 함수
  - deque.pop(): deque의 맨 오른쪽의 값을 삭제하고 리턴한다.
  - deque.popleft(): deque의 맨 왼쪽의 값을 삭제하고 리턴한다. 
  - deque.remove(a): 오른쪽에서부터 탐색해가며 a라는 값이 나오면 삭제한다.
- 기타 함수
  - deque.reverse(): deque를 역순으로 뒤집는다.
  - deque.extend(deque2): 오른쪽으로 deque와 deque2를 확장한다.
  - deque.extendleft(deque2): 왼쪽으로 deque와 deque2를 확장한다.
  - deque.rotate(1): 오른쪽으로 1칸 rotate한다.
  - deque.rotate(-1): 왼쪽으로 1칸 rotate한다.


### Priority Queue
- `heapq`를 통해서 쉽게 빠른 우선순위 큐를 구현할 수 있다. heapq는 최소 힙만을 지원한다. 최대 힙으로 사용하려면 push할때 key를 -를 붙여서 삽입하면 된다. 이 문서에서는 가장 일반적이고 성능이 좋은 heapq를 기반으로 설명할 것이다.
- 생성 관련 함수
  - heapq 모듈은 생성관련 함수는 딱히 없으나 heap 형태로 튜플 데이터를 저장하는 리스트를 미리 선언해야한다.
- 삽입 관련 함수
  - heapq.heappush(list, (key,value)): list에 key와 value로 이뤄진 튜플을 삽입한다.
- 삭제 관련 함수
  - heapq.heappop(list): heapq 모듈에 의해 들어간 (key,value)는 key라는 우선순위에 따라 키값이 낮은 순서대로 리턴한다.
- 참조 관련 함수
  - list[idx]: heapq 모듈로 배열된 순서대로 해당 인덱스에 있는 리스트의 원소를 리턴한다.
- 기타 함수
  - heapq.heapify(list): (key,value) 튜플로 이뤄진 리스트 또는 단일 키값으로 이뤄진 리스트를 힙 정렬하여 반환한다. 


### Dictionary(Map)
- 딕셔너리는 파이썬의 내장 자료형으로 파이썬에서 간단하게 해시테이블 구조의 자료구조를 이용할 때 사용한다.
- 생성 관련 함수
  - dict(): 비어 있는 딕셔너리를 생성한다.
  - {}: 비어 있는 딕셔너리를 생성한다.
- 삽입 관련 함수
  - dict.update(dict2): dict과 dict2를 합친다.
- 삭제 관련 함수
  - dict.pop(key): key에 대한 값을 리턴하고 삭제한다.
- 참조 관련 함수
  - dictionary[key]: 해당 key에 있는 값을 리턴한다.
- 탐색 관련 함수
  - dict.get(key): key에 대한 값을 리턴하는데 입력된 키가 없으면 디폴트 값을 리턴한다.
- 기타 함수
  - dict.items(): 딕셔너리의 키와 값을 (key,value) 쌍의 튜플 목록들로 리턴한다.
  - dict.keys(): 딕셔너리의 키들을 목록으로 리턴한다.
  - dict.values(): 딕셔너리의 값들을 목록으로 리턴한다.
  - json.loads(string): dictionary 형식의 문자열을 딕셔너리 형태로 변환하여 리턴한다.
  - json.dumps(dict): dictionary를 문자열 형태로 변환하여 리턴한다.


### Set
- 셋은 파이썬의 내장 자료형으로 중복 값을 삽입 할 수 없는 리스트로서 파이썬에서 간단하게 집합 연산을 이용할 때 사용한다.
- 생성 관련 함수
  - set()
- 삽입 관련 함수
  - set.add(a): a를 set에 삽입한다.
  - set.update(a): a(container)를 set에 삽입한다.
- 삭제 관련 함수
  - set.remove(a): set에서 a를 삭제하는데 a가 set에 존재하지 않으면 예외를 일으킨다.
  - set.discard(a): set에서 a를 삭제하는데 a가 set에 존재하지 않아도 예외를 일으키지 않는다.
- 기타 함수
  - set(객체): iterable 객체를 집합으로 형변환한다.
  - set | set2: set와 set2의 합집합을 리턴한다.
  - set & set2: set와 set2의 교집합을 리턴한다.
  - set - set2: set와 set2의 차집합을 리턴한다.
  - set.issubset(set2): set이 set2의 부분 집합이면 True 아니면 False를 리턴한다.
  - set.issuperset(set2): set이 set2의 슈퍼 집합이면 True 아니면 False를 리턴한다.
  - set.isdisjoint(set2): set과 set2 사이에 교집합이 있으면 True 없으면 False를 리턴한다.


### Python 유용한 외장 모듈
- `copy`
  - 변수 = copy.deepcopy(객체): 객체 간의 깊은 복사를 이용할 때 사용한다.
- `clollections.defaultdict`
  - dict의 하위 클래스로 key에 대한 value가 없을 때 default값을 자동으로 넣어 주는 모듈
  - defaultdict(list): value가 기본으로 list이기 때문에 객체[key].append()를 활용해서 값 추가  
  - defaultdict(set): value가 기본으로 set이기 때문에 객체[key].add()를 활용해서 값 추가 
  - defaultdict(int): key에 대한 값이 없을 때 기본으로 0으로 초기화
- `itertools.combinations`
  - itertools.combinations(p, r): iterable 객체 p에 대해 r만큼의 길이에 대한 순서가 없고 중복도 없는 조합을 리턴
- `itertools.combinations_with_replacement`
  - itertools.combinations_with_replacement(p, r): iterable 객체 p에 대해 r만큼의 길이에 대한 순서가 없고 중복은 있는 조합을 리턴
- `itertools.permutations`
  - itertools.permutations(p, r): iterable 객체 p에 대해 r만큼의 길이에 대한 순서가 있고 중복도 있는 순열을 리턴
- `itertools.chain`
  - itertools.chain.from_iterable(p): iterable 객체 p에 대해서 N차원 iterable 객체를 1차원으로 바꾸고 리턴


### Python 유용한 내장 함수
 - 객체.sort(Key=?,reverse=?): 객체를 내부적으로 정렬한다. Key 함수를 통해서 정렬 옵션을 선택할 수 있고 reverse 매개변수를 통해서 True는 내림차순, False는 오름차순으로 정할 수 있다.
 - sorted(객체,Key=?,reverse=?): 객체를 내부적으로 정렬한 뒤 리턴한다. Key 함수를 통해서 정렬 옵션을 선택할 수 있고 reverse 매개변수를 통해서 True는 내림차순, False는 오름차순으로 정할 수 있다.
 - min(객체): 갹체 안에서 최소 값을 리턴한다. Key 함수를 통해서 탐색 옵션을 선택할 수 있다.
 - max(객체): 객체 안에서 최대 값을 리턴한다. Key 함수를 통해서 탐색 옵션을 선택할 수 있다.
 - len(객체): 객체의 전체 길이를 리턴한다.
 - a,b = divmod(int,int): 몫과 나머지를 한번에 리턴한다.
 - del 객체: 파이썬의 모든 자료 형은 객체인데 이 객체를 삭제한다.
 - 객체.clear(): 객체를 삭제한다.


### Python 정규표현식
- import re를 통해서 정규표현식 관련된 라이브러리 함수를 사용할 수 있는데 정규표현식 정의 시에는 r을 붙여서 별도로 `\`를 사용하는 경우 `\\`를 사용하지 않아도 매칭될 수 있게 할 수 있다.
- 정규표현식 특수기호
  1. `^`: 매칭할 문자열의 맨 앞을 타겟으로 패턴 매칭
  2. `$`: 매칭할 문자열의 맨 뒤를 타겟으로 패턴 매칭
  3. `\`: 특수기호를 패턴이 아닌 문자로 사용하고 싶으면 \{특수기호}를 사용 `ex) \$`
  4. `.`: 모든 문자와 매칭
  5. `[]`: [] 안에 있는 모든 문자를 매칭할 문자열의 문자 1개와 패턴 매칭
  6. `[-]`: [] 안에서 문자의 범위를 지정할 때 사용 `ex) [a-d]: a-d와 매칭`
  7. `[^]`: [] 안에서 문자의 범위를 제외할 때 사용 `ex) [^a-d]: a-d 이외의 문자들과 매칭`
  8. `()`: () 안에 있는 모든 문자열을 서브 그룹으로 지정하여 매칭할 문자열과 매칭 
  9. `(|)`: () 안에 있는 모든 문자열을 |을 통해 여러 개 설정하여 매칭 `ex) (abc|edf)`
  10. `*`: \* 앞에 있는 문자가 매칭할 문자열에 0개~여러 개 있을 때 최대한 Greedy 매칭 `ex) [a-z]*`
  11. `+`: \+ 앞에 있는 문자가 매칭할 문자열에 1개~여러 개 있을 때 최대한 Greedy 매칭 `ex) [a-z]+` 
  12. `?`:  \? 앞에 있는 문자가 매칭할 문자열에 0개~1개 있을 때 매칭 `ex) [a-z]?`
  13. `{숫자}`: {} 안에 있는 숫자만큼 매칭할 문자열에 매칭 `ex) [a-z]{3}`
  14. `{숫자1,숫자2}`: {} 안에 있는 숫자1보다 크거나 같고 숫자2보다 작거나 같은 숫자 만큼 매칭할 문자열에 매칭 `ex) [a-z]{1,3}`
  15. `{숫자,}`: {} 안에 있는 숫자 이상만큼 매칭할 문자열에 매칭 `ex) [a-z]{3,}`
  16. `*?`: Greedy 수량자인 *의 Greedy 속성을 Lazy 속성으로 변환하여 해당 상황에서 0개~여러 개로 확장할 수 있는 한 Lazy 매칭 `i\w*?n`
  17. `+?`: Greedy 수량자인 +의 Greedy 속성을 Lazy 속성으로 변환하여 해당 상황에서 1개~여러 개로 확장할 수 있는 Lazy 한 매칭 `i\w+?n`
  18. `\w`: 워드, [A-z0-9__]와 동일한 의미
  19. `\W`: 워드가 아닌 것 , 즉 [^A-z0-9__]와 동일한 의미
  20. `\d`: 숫자, [0-9]와 동일한 의미
  21. `\D`: 숫자가 아닌 것, 즉 [^0-9]와 동일한 의미
  22. `\b`: 워드 바운더리, 단어가 경계를 지정할 때 사용 ex) `\bABC\b`: ABC가 독립 `\bABC`: ABC로 시작 `ABC\b`: ABC로 종료
  23. `B`: 워드 바운러디가 아닌 것, 단어가 경계가 아닌 것을 지정할 때 사용
- 정규표현식 패턴
  1. 전화번호: /^\d{3}-\d{3,4}-\d{4}$/
  2. 이메일: /^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*\.[a-zA-Z]{2,3}$/i 
  3. 핸드폰번호: /^01([0|1|6|7|8|9]?)-?([0-9]{3,4})-?([0-9]{4})$/
  4. URL: ^(https?):\/\/([^:\/\s]+)(:([^\/]*))?((\/[^\s/\/]+)*)?\/?([^#\s\?]*)(\?([^#\s]*))?(#(\w*))?$  
  5. 음수가 포함되는 나눗셈 없는 수식: /'[\-]?[0-9]+[\*\+\-][\-]?[0-9]+'/
- 정규표현식 특징
  1. 정규표현식은 대소문자를 구분합니다.
  2. 정규표현식 패턴의 기본은 문자열 패턴을 그대로 매칭
  3. 공백도 문자로 인식하여 매칭 
- 컴파일 함수
  - re.compile(r'정규표현식'): 해당 정규표현식 패턴을 사용할 수 있는 객체 생성하여 리턴하는데 이 객체를 통하면 검색함수에서 re모듈과 정규표현식을 생략할 수 있고 안정적이다.
- 검색 함수
  - re.match(r'정규표현식', 매칭할 문자열): 매칭할 문자열과 처음부터 매칭되는지 확인하고 부합하면 Match 객체를 리턴한다.
  - re.search(r'정규표현식', 매칭할 문자열): 매칭할 문자열을 전체를 검색하고 부합하면 Match 객체를 리턴한다.
  - re.findall(r'정규표현식', 매칭할 문자열): 매칭할 문자열과 매칭되는 모든 문자열을 리스트로 리턴한다.
- Match 객체
  - match.group(): 매치된 문자열을 리턴한다.
  - match.start(): 매치된 문자열의 시작 위치를 리턴한다.
  - match.end(): 매치된 문자열의 종료 위치를 리턴한다.
  - match.span(): 매치된 문자열의 (시작,종료)를 튜틀로 리턴한다.


### 자료구조(배열, 스택, 큐, 힙, 해시) 문제 Tip
- Python의 Set과 Dictionary를 이용하면 해시처럼 사용할 수 있습니다.
- Python의 List를 이용할 때 빠르게 사용하는 방법은 append()를 사용하여 값을 추가하는 것이 아닌 미리 필요한 크기만큼 할당해놓고 index로 접근하여 값을 저장하는 것 입니다.


### 정렬 문제 Tip
- 파이썬 내장 정렬 함수인 sort 함수의 사용법을 익히면 매우 유용합니다.


### 탐색(완전탐색, 이분탐색) 문제 Tip


### 그래프 문제 Tip
- BFS는 방문이 필요한 노드를 저장하는 큐와 방문이 끝난 큐 2개로 쉽게 구현할 수 있습니다.
- DFS는 방문이 필요한 노드를 저장하는 스택과 방문이 끝난 큐 각각 1개로 쉽게 구현할 수 있습니다.
- 최단 경로 탐색 시에는 BFS를 이용해야합니다.
- 싱글 노드의 최단 경로를 찾는 음의 가중치가 없는 경우 다익스트라 알고리즘을 있는 경우 벨만 포드 알고리즘을 사용합니다.
- 모든 노드 쌍의 최단 경로를 찾는 알고리즘은 플루이드 워샬 알고리즘을 사용합니다.
- 입력 데이터의 형식이 숫자인 경우 미리 큰 리스트를 할당하고 활용하여 시간 복잡도를 줄일 수 있습니다.


### 동적 계획법 문제 Tip
- 동적 계획법은 부분 문제로 나누고 메모리제이션을 과정을 통해 이전 결과를 저장하여 다음 연산 시에 사용한다는 특징이 있습니다.
- 기본적으로 인접한 항들의 관계를 파악하여 점화식을 세우고 그 점화식을 코드로 구현하는 것이 핵심입니다.
- 전형적인 DP 문제는 각각의 변수에 대해서 테이블을 만들고 테이블의 값을 저장하고 이후에 점화식을 통해 이전 테이블의 값을 이용하여 테이블을 확장하여 해결합니다.


### 분할 정복 문제 Tip
- 분할 정복 알고리즘과 동적 계획법 알고리즘의 차이는 부분 문제로 나누는 것은 같지만 동적 계획 알고리즘은 이전 결과를 다음 결과에서 사용하나 분할 정복은 이전 결과를 다음 결과에서 사용하지 않고 별도로 취합한다는 차이가 있습니다.
- 분할 정복 알고리즘은 재귀 호출을 통해서 쉽게 구현할 수 있습니다.


### 그리디 문제 Tip


### 백트래킹 문제 Tip


### 문자열 문제 Tip
- 정규표현식을 활용하면 문자열 처리가 쉽습니다.
